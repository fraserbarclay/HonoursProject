<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Body Dimension Analysis</title>
    <script src="https://cdn.socket.io/socket.io-1.3.5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/91/three.min.js"></script>
    <script>
        var socket = io.connect('http://localhost:8000/');

        //socket.on('bodyFrame', interpretData);

        socket.on('rawDepthFrame', logData);

        var depthWidth = 512;
        var depthHeight = 424;

        var camera, scene, renderer;
        var geometry, material, points;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, 1, 1, 10000);

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(1024, 848);
            renderer.setClearColor(0x333333);
            document.body.appendChild(renderer.domElement);

            geometry = new THREE.Geometry();
            material = new THREE.PointsMaterial({
                color: "white"
                //,size: 1
            });

            pointCloud = new THREE.Points(geometry, material);

        }

        function logData(rawDepthFrame) {
            //points = new Array(217088);

            var data = rawDepthFrame;
            //console.log(data);
            var dataArray = new Int16Array(rawDepthFrame);
            //console.log(dataArray);

            var count = 0;
            for (var i = 0; i < depthWidth; i++) {
                for (var j = 0; j < depthHeight; j++) {
                    var offset = i + j * 512;
                    var d = dataArray[offset];
                    //var d = (dataArray[count+1] << 16) + dataArray[count];
                    //console.log(i + ", " + j + ", " + d)
                    point = new THREE.Vector3(i, j, d);
                    point = depthToPointCloudPos(point);
                    //console.log(point.x + ", " + point.y + ", " + point.z)
                    if (count < geometry.vertices.length){
                        geometry.vertices[count] = point;
                    } else {
                        geometry.vertices.push(point);
                    }
                    count++;
                }
            }

            /*
            // Simple sphere
            var i = 0;
            while (i < 1000) {
                var x = 2 * Math.random() - 1;
                var y = 2 * Math.random() - 1;
                var z = 2 * Math.random() - 1;
                if (x * x + y * y + z * z < 1) { // only use points inside the unit sphere
                    points[i] = new THREE.Vector3(x, y, z);
                    i++;
                }
            }*/

            /*for (i = 0; i < points.length; i++) {
                geometry.vertices.push(points[i]);
            }*/

            scene.add(pointCloud);

            camera.position.x = -300;
            camera.position.y = 300;
            camera.position.z = 2500; 
            //camera.r

            animate();
        }

        function animate() {
            //requestAnimationFrame(animate);
            //pointCloud.rotation.y = 3.4;
            //pointCloud.rotation.x = 3;
                        //pointCloud.rotation.x += 0.1;

            //pointCloud.rotation.y += 0.01;
            //console.log(pointCloud.rotation.x);
            geometry.verticesNeedUpdate = true;
            renderer.render(scene, camera);
        }

        //calculte the xyz camera position based on the depth data
        function depthToPointCloudPos(point) {
            point.z = (point.z);
            point.x = (point.x - 254.878) * point.z / 365.456;
            point.y = (point.y - 205.395) * point.z / 365.456;
            return point;
        }

        /*function interpretData(bodyFrame) {
            var user = null;
            for (i = 0; i < 6; i++) {
                if (bodyFrame.bodies[i].tracked == true) {
                    user = bodyFrame.bodies[i];
                } else {
                    //console.log(bodyFrame.bodies[i].tracked);
                }
            }

            if (user != null) {
                var head = user.joints[3];
                var neck = user.joints[2];
                var shoulder = user.joints[20];
                var midBack = user.joints[1];
                var spineBase = user.joints[0];

                var leftHip = user.joints[12];
                var rightHip = user.joints[16];

                var leftKnee = user.joints[13];
                var rightKnee = user.joints[17];
                var leftAnkle = user.joints[14];
                var rightAnkle = user.joints[18];
                var leftFoot = user.joints[15];
                var rightFoot = user.joints[19];

                var leftShoulder = user.joints[4];
                var rightShoulder = user.joints[8];

                var width = calculateDistance(leftShoulder, rightShoulder);

                var topHeight = calculateDistance(head, neck) + calculateDistance(neck, shoulder) +
                    calculateDistance(shoulder, midBack) + calculateDistance(midBack, spineBase) +
                    ((calculateDistance(spineBase, leftHip) + calculateDistance(spineBase, rightHip)) / 2);
                var legHeight = ((calculateDistance(leftHip, leftKnee) + calculateDistance(leftKnee, leftAnkle) +
                    calculateDistance(leftAnkle, leftFoot)) + (calculateDistance(rightHip, rightKnee) +
                    calculateDistance(rightKnee, rightAnkle) + calculateDistance(rightAnkle, rightFoot))) / 2;
                var totalHeight = (topHeight + legHeight).toFixed(2);

                document.getElementById("height").innerHTML = "Height: " + totalHeight + "m";
                document.getElementById("width").innerHTML = "Width: " + width + "m";
                drawDotFigure(bodyFrame);
            }
        }

        function calculateDistance(joint1, joint2) {
            var distance = Math.sqrt(Math.pow(joint1.cameraX - joint2.cameraX, 2) +
                Math.pow(joint1.cameraY - joint2.cameraY, 2) +
                Math.pow(joint1.cameraZ - joint2.cameraZ, 2))
            return distance;
        }

        function drawDotFigure(bodyFrame) {
            var c = document.getElementById('canvas');
            var ctx = c.getContext('2d');

            ctx.clearRect(0, 0, c.width, c.height);

            for (var i = 0; i < bodyFrame.bodies.length; i++) {
                if (bodyFrame.bodies[i].tracked == true) {
                    for (var j = 0; j < bodyFrame.bodies[i].joints.length; j++) {
                        var joint = bodyFrame.bodies[i].joints[j];
                        ctx.fillStyle = "#FF0000";
                        ctx.beginPath();
                        ctx.arc(joint.depthX * 400, joint.depthY * 400, 10, 0, Math.PI * 2, true); //multiplied with static integer 400 in order to adjust position on canvas as without it skeleton projection formed is only visible in a corner as DepthX values were always less than 1
                        ctx.closePath();
                        ctx.fill(); //drawing a circle for each joint on the canvas 
                    }
                }
            }
        } */
    </script>
</head>

<body onload="init()">
    <h1 id="height" style="font-size: 72px"></h1>
    <br>
    <h1 id="width" style="font-size: 72px"></h1>
    <br>
    <h1 id="depth" style="font-size: 72px"></h1>
    <br>
    <canvas id="canvas" width="640" height="480"></canvas>
</body>

</html>